[Doc Link](https://drive.xttech.tech/s/Drz7B5xXrFAYwik)

SHIM Paper:

[https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/preprint.pdf](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/preprint.pdf)

What Shim is:



*   SHIM is a profiling tool that has been designed to perform better than other profiling tools such as Intel’s Vtune and Perf.
*   Uses a mixed approach of Sampling and Tracing
    *   Uses tracing methods to gather information (by using unutilized hardware to run a thread to gather tracing information), but still follows a sampling procedure

Concepts in Shim:



1. Signals:
    1. Signals in SHIM are time-varying software and hardware events
    2. SHIM will record performance counters and memory locations associated with these signals
    3. Events may be in the form of tags, counters and rates.
        1. Tags are arbitrary can be method ID, program counter, or stack pointer
        2. Counter is incremented when an event occurs
        3. A rate is how much a counter changes over time, so the start and end of a sample period records the counter and clock each time to calculate the rate of change
2. Double Time Error Correction (DTE)
    4. A method or algorithm that “automatically identifies and discards noisy samples by taking redundant timing measurements.“
    5. Measures the clock value at the start of one sample measurement and the end and does the same for the consequent sample, finds the difference between both starts and both ends respectively and then calculates the ratio of the two. If this ratio = 1 then this means that there was no deviation between the two samples thus they are accurate samples and are kept.
3. Observer effects
    6. When the process of trying to record and analyze performance information has an effect on the program’s overall runtime/performance.
    7. We want as little of this as possible to have our data more accurately represent the original application

SHIM’s Implementation:



1. Has an observer thread executing continuously on a separate hardware context either by running on unutilized hardware like a different core or on the same core using Simultaneous Multithreading 
2. Samples signals automatically generated by hardware in performance counters and memory locations for software
3. Consists of 3 components/subsystems
    1. Coordinator
        1. Configures/Prepares hardware and software so that observer threads and the software to be analyzed are on the appropriate hardware or context for recording (As described in (1) of this section).
        2. This is also will configure hardware performance counters so that they can be read
        3. Also configures software signal generation so that memory address of the signals can be determined
        4. Sends signal type, performance counters and memory locations for signals to observer threads
        5. Also adds a software signal to the OS that IDs app threads
    2. Sampler
        6. Observer threads implement this, will sample hardware/software signals at a rate defined by the coordinator 
        7. Hardware signals are read via performance counters and software signals are read via memory locations
        8. Uses a buffer for samples
        9. Reads the signals in a busy loop and writes to buffer
        10. 

<p id="gdcalert1" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image1.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert2">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image1.png "image_tooltip")

        11. Makes use of rdtscp() instruction to have “high fidelity in-order” measurements of counters and rates
    3. Software signal generator
        12. Generates software signals
        13. Selects software/hardware signals
        14. Can choose and configure hardware performance counter events for hardware signals
        15. Can measure how many instructions are run by the application thread in a simultaneous multithreading situation involving 2 threads (app and SHIM observer) by finding the difference in the total instructions ran by the core and the instructions run for SHIM
        16. Memory address of software signal is recorded when recording software signals
            1. Software signals are already generated automatically for various reasons such as memory allocation, there is an example of “bump pointers” which reflect memory allocation
        17. Memory address updates are communicated to SHIM 
            2. Less intrusive than instrumentation of writing/saving the address for frequently written variables
        18. Cannot avoid instrumentation completely, some signals may need it
            3. SHIM does this by modifying Jikes RVM compiler
                1. With each signal, SHIM makes the application/program write the signal value to the same memory address repeatedly
                    1. Has been shown to incur little overhead on CMP (Chip multiprocessor) due to good locality
                    2. Some architectures use write-back which works well with the repeated writes to the same address
4. Methodology
    4. Used Jikes RVM to implement SHIM
        19. Jikes RVM is “a Java-in-Java high performance Virtual Machine.”
    5. At time of paper, used Kernel 3.17.0 with perf subsystem and added a software signal to linux that can identify threads
    6. Used 4 CMP cores that had 2-way SMT for 8 hardware contexts